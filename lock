#!/bin/bash

# Constants
DISPLAY_RE="([0-9]+)x([0-9]+)\\+([0-9]+)\\+([0-9]+)"  # Regex to find display dimensions
FOLDER=`dirname "$BASH_SOURCE"`  # Current folder

# Cache (create folder if not there yet)
CACHE_FOLDER="$FOLDER"/image_cache/
if ! [ -e $CACHE_FOLDER ]; then
	mkdir $CACHE_FOLDER
fi

# Passed arguments
while getopts ":i:a:" opt; do
	case $opt in
		i) arg_image="$OPTARG"
		;;
		a) lock_args="$OPTARG"
		;;
		\?) echo "Invalid option -$OPTARG" >&2 && exit 1
		;;
	esac
done

# Background image path
if [ "$arg_image" ]; then
	BKG_IMG="$arg_image"  # Passed image
else
	BKG_IMG="$FOLDER/background.png"  # Default
fi

# Exit if no image
if ! [ -e "$BKG_IMG" ]; then
	echo "No background image! Exiting..."
	exit 2
fi

MD5_BKG_IMG=$(md5sum $BKG_IMG | cut -c 1-8)  # Just another layer of unique-ness for each image 
OUTPUT_IMG="$CACHE_FOLDER"."$MD5_BKG_IMG".png  # Path of final image
OUTPUT_IMG_WIDTH=0  # Decide size to cover all screens
OUTPUT_IMG_HEIGHT=0  # Decide size to cover all screens

# i3lock command
LOCK_BASE_CMD="i3lock -i $OUTPUT_IMG"
if [ "$lock_args" ]; then
	LOCK_ARGS="$lock_args"  # Passed command
else
	LOCK_ARGS="-t -p default -e"  # Default
fi
LOCK_CMD="$LOCK_BASE_CMD $LOCK_ARGS"

# If the image already exists (in cache) then lock the screen and exit:
if [ -e $OUTPUT_IMG ]; then
	$LOCK_CMD
	exit 0
fi

# Execute xrandr to get information about the monitors:
#while read LINE
#do
while IFS= read -r LINE; do
	# If we are reading the line that contains the position information:
	if [[ $LINE =~ $DISPLAY_RE ]]; then
		# Extract information and append some parameters to the ones that will be given to ImageMagick:
		SCREEN_WIDTH=${BASH_REMATCH[1]}
		SCREEN_HEIGHT=${BASH_REMATCH[2]}
		SCREEN_X=${BASH_REMATCH[3]}
		SCREEN_Y=${BASH_REMATCH[4]}
    
		CACHE_IMG="$CACHE_FOLDER""$SCREEN_WIDTH"x"$SCREEN_HEIGHT"."$MD5_BKG_IMG".png
		# If cache for that screensize doesnt exist
		if ! [ -e $CACHE_IMG ]; then
			#eval convert '$BKG_IMG' '-resize' '${SCREEN_WIDTH}X${SCREEN_HEIGHT}!' '$CACHE_IMG'
			eval convert '$BKG_IMG' '-resize' '${SCREEN_WIDTH}X${SCREEN_HEIGHT}^' '-gravity' 'Center' '-crop' '${SCREEN_WIDTH}X${SCREEN_HEIGHT}+0+0' '+repage' '$CACHE_IMG'
		fi

		# Decide size of output image
		if (( $OUTPUT_IMG_WIDTH < $SCREEN_WIDTH+$SCREEN_X )); then OUTPUT_IMG_WIDTH=$(($SCREEN_WIDTH+$SCREEN_X)); fi;
		if (( $OUTPUT_IMG_HEIGHT < $SCREEN_HEIGHT+$SCREEN_Y )); then OUTPUT_IMG_HEIGHT=$(( $SCREEN_HEIGHT+$SCREEN_Y )); fi;

		PARAMS="$PARAMS $CACHE_IMG -geometry +$SCREEN_X+$SCREEN_Y -composite "
	fi
done <<<"$(echo "`xrandr | grep -Po $DISPLAY_RE`")"

# Execute ImageMagick:
eval convert -size ${OUTPUT_IMG_WIDTH}x${OUTPUT_IMG_HEIGHT} 'xc:black' $OUTPUT_IMG
eval convert $OUTPUT_IMG $PARAMS $OUTPUT_IMG

# Execute the command and lock the screen:
$LOCK_CMD
